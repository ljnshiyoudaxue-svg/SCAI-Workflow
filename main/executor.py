# executor.py
# --------------------------------------------------
# DeepSeek Plan Executor
# Responsibility:
#   - Execute planner-generated PLAN
#   - Manage shared execution context
#   - Call tools from TOOL_REGISTRY
# --------------------------------------------------

from typing import Dict, Any, List


class ExecutionError(Exception):
    """Custom exception for execution failures"""
    pass


# ===============================
# ğŸ§  Tool Invocation Helper
# ===============================

def resolve_inputs(inputs: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
    """
    Resolve inputs that reference previous step outputs.
    Convention:
        "$<key>"  -> context["<key>"]
    """
    resolved = {}

    for k, v in inputs.items():
        if isinstance(v, str) and v.startswith("$"):
            ref_key = v[1:]
            if ref_key not in context:
                raise ExecutionError(f"Missing context key: {ref_key}")
            resolved[k] = context[ref_key]
        else:
            resolved[k] = v

    return resolved


def execute_tool(tool_name: str, tool_registry: Dict[str, Any], inputs: Dict[str, Any]):
    """
    Execute a single tool.
    """
    if tool_name not in tool_registry:
        raise ExecutionError(f"Tool '{tool_name}' not found in registry")

    tool_fn = tool_registry[tool_name]["func"]

    try:
        return tool_fn(**inputs)
    except Exception as e:
        raise ExecutionError(f"Tool '{tool_name}' failed: {e}")


def filter_inputs_for_tool(
    tool_name: str,
    inputs: Dict[str, Any],
    tool_registry: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Remove inputs that are not declared in tool registry.
    """
    tool_meta = tool_registry.get(tool_name, {})
    allowed_inputs = tool_meta.get("inputs", [])

    if not allowed_inputs:
        return inputs  # no constraint

    return {
        k: v for k, v in inputs.items()
        if k in allowed_inputs
    }


# ===============================
# ğŸš€ Main Executor
# ===============================

def execute_plan(
    plan: Dict[str, Any],
    tool_registry: Dict[str, Any],
    image_path: str = None,
    user_context: Dict[str, Any] = None
) -> Dict[str, Any]:
    """
    Execute the PLAN generated by planner.

    Returns:
        execution_result (dict): intent, context, log
    """

    context: Dict[str, Any] = {}
    execution_log: List[str] = []

    # â‘  ç”¨æˆ·å‚æ•°æ³¨å…¥ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰
    if user_context:
        if not isinstance(user_context, dict):
            raise ExecutionError("user_context å¿…é¡»æ˜¯ dict")
        context.update(user_context)

    # â‘¡ æ—¥å¿—å‡½æ•°
    context["log_fn"] = print

    # â‘¢ image_path æ³¨å…¥
    if image_path is not None:
        context["image_path"] = image_path
        context["user_image"] = image_path
        context["image"] = image_path

    steps = plan.get("plan", [])

    if not steps:
        return {
            "intent": plan.get("intent", ""),
            "context": context,
            "log": ["No execution steps required."]
        }

    for step in steps:
        step_id = step.get("step")
        tool_name = step.get("tool")
        raw_inputs = step.get("inputs", {})
        outputs = step.get("outputs", [])

        execution_log.append(f"â–¶ Step {step_id}: {tool_name}")

        resolved_inputs = resolve_inputs(raw_inputs, context)
        resolved_inputs = filter_inputs_for_tool(
            tool_name, resolved_inputs, tool_registry
        )

        result = execute_tool(tool_name, tool_registry, resolved_inputs)

        if outputs:
            if len(outputs) == 1:
                context[outputs[0]] = result
            else:
                if not isinstance(result, dict):
                    raise ExecutionError(
                        f"Tool '{tool_name}' must return dict for multiple outputs"
                    )
                for out_key in outputs:
                    if out_key not in result:
                        raise ExecutionError(
                            f"Missing output '{out_key}' from tool '{tool_name}'"
                        )
                    context[out_key] = result[out_key]

        execution_log.append(f"âœ” Step {step_id} completed")

    return {
        "intent": plan.get("intent", ""),
        "context": context,
        "log": execution_log
    }




